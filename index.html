<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Denver Barometric Pressure — Observed • Historical • Forecast</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- ECharts -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root{
      color-scheme: light dark;
      --bg: #0b0c10;
      --card: rgba(255,255,255,.06);
      --border: rgba(255,255,255,.12);
      --fg: #e9eef6;
      --muted: #9aa3af;
      --accent: #60a5fa;    /* Observed */
      --accent-2: #22d3ee;  /* Historical */
      --accent-3: #a78bfa;  /* Forecast */
      --ok: #34d399;
      --err: #ef4444;
      --warn: #f59e0b;
      --radius: 18px;
      --shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg: #f8fafc;
        --card: #ffffffcc;
        --border: rgba(15,23,42,.08);
        --fg: #0f172a;
        --muted: #475569;
        --shadow: 0 12px 24px rgba(2,6,23,.08);
      }
    }
    *{ box-sizing: border-box }
    html, body{ height:100% }
    body{
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      /* Sleeker single, fixed, non-repeating gradient */
      background:
              radial-gradient(1300px 900px at 12% -10%, rgba(96,165,250,.22), transparent 65%),
              radial-gradient(1500px 1000px at 110% 0%, rgba(167,139,250,.18), transparent 62%),
              var(--bg);
      background-repeat: no-repeat, no-repeat, no-repeat;
      background-attachment: fixed, fixed, fixed;
      background-size: 1400px 900px, 1600px 1000px, auto;
      color: var(--fg);
      padding: clamp(14px, 3vw, 28px);
    }
    .wrap{ max-width: 1100px; margin: 0 auto; display: grid; gap: 16px; }
    h1{ margin: 0; font-weight: 700; font-size: clamp(1.1rem, 2.4vw, 1.6rem); letter-spacing: .2px; }

    .card{
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .pad{ padding: 12px; }

    .sub{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; font-size:.95rem; color:var(--muted); }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 6px 10px; border-radius: 999px;
      background: var(--card); border: 1px solid var(--border);
      backdrop-filter: blur(8px);
    }
    .badge{ width:10px; height:10px; border-radius:999px; background: var(--ok); }

    /* Segmented control */
    .seg{
      display:inline-grid;
      grid-auto-flow: column;
      gap: 6px;
      padding: 6px;
      border-radius: 14px;
      background: var(--card);
      border: 1px solid var(--border);
    }
    .seg button{
      appearance:none; border:1px solid var(--border); background:transparent;
      color:var(--fg); padding:8px 12px; border-radius:10px; cursor:pointer; font-size:.92rem;
    }
    .seg button[aria-pressed="true"]{
      background: color-mix(in hsl, var(--accent) 12%, var(--card));
      outline: 2px solid color-mix(in hsl, var(--accent) 55%, transparent);
    }
    .seg [data-mode="observed"][aria-pressed="true"]{ outline-color: color-mix(in hsl, var(--accent) 55%, transparent) }
    .seg [data-mode="historical"][aria-pressed="true"]{ outline-color: color-mix(in hsl, var(--accent-2) 55%, transparent) }
    .seg [data-mode="forecast"][aria-pressed="true"]{ outline-color: color-mix(in hsl, var(--accent-3) 55%, transparent) }

    .toolbar{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:space-between; }
    .toolbar .right{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .inputs{
      display:grid; grid-template-columns: minmax(0,1fr) minmax(0,1fr) auto; gap:8px; align-items:start;
      margin-right: 25px;
    }
    @media (max-width: 780px){ .inputs{ grid-template-columns: 1fr; } }
    label{ font-size:.86rem; color:var(--muted); display:block; margin: 0 0 6px; }
    input[type="datetime-local"], input[type="number"], select.sel{
      width: 100%;
      border:1px solid var(--border); background:var(--card); color:var(--fg);
      padding:10px 12px; border-radius:12px; min-width:0;
    }
    .btn{
      appearance:none; border:1px solid var(--border); background:var(--card);
      color:var(--fg); padding:8px 12px; border-radius:12px; cursor:pointer; font-size:.92rem;
      backdrop-filter: blur(6px);
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ border-color: color-mix(in hsl, var(--accent) 50%, var(--border)); }
    .btn.chip{ padding:6px 10px; font-size:.9rem }

    .status{
      font-size: .95rem; color: var(--muted);
      display:flex; align-items:center; gap:8px; margin-bottom: 8px;
    }
    .dot{ width:8px; height:8px; border-radius:999px; background: var(--warn); }

    /* Chart */
    #chart{ width:100%; height: clamp(320px, 48vh, 560px); border-radius: calc(var(--radius) - 6px); overflow:hidden; }
    /* Load mask */
    .chart-card{ position: relative; }
    .chart-mask{
      position:absolute; inset:12px 12px 12px 12px; /* respect card padding */
      display:none; align-items:center; justify-content:center; gap:12px;
      backdrop-filter: blur(6px);
      background: color-mix(in hsl, var(--bg) 30%, transparent);
      border-radius: calc(var(--radius) - 6px);
      z-index: 5;
      pointer-events: none;
    }
    .chart-mask.show{ display:flex; }
    .spin{
      width:22px; height:22px; border-radius:999px;
      border:3px solid color-mix(in hsl, var(--fg) 25%, transparent);
      border-top-color: var(--accent);
      animation: spin 1s linear infinite;
    }
    @keyframes spin{ to{ transform: rotate(360deg) } }
    .mask-text{ font-size:.95rem; color: var(--muted) }

    .table-card{ padding: 12px; }
    table{ width:100%; border-collapse: collapse; font-size: clamp(.86rem, 1.5vw, .95rem); }
    thead th{
      color: var(--muted); font-weight: 600; text-align: left; padding: 10px; border-bottom: 1px solid var(--border);
      position: sticky; top: 0; backdrop-filter: blur(6px);
      background: color-mix(in hsl, var(--card) 70%, transparent); z-index:1;
    }
    tbody td{ padding:10px; border-bottom:1px solid var(--border); white-space:nowrap; }
    .muted{ color: var(--muted) }
    .hide-sm{ } @media (max-width:540px){ .hide-sm{ display:none } }

    .row-flex{ display:flex; gap:8px; align-items:end; flex-wrap:wrap }
    .hidden{ display:none !important; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Denver Barometric Pressure</h1>
    <div class="sub">
      <span class="pill"><span class="badge" aria-hidden="true"></span> <strong>Station:</strong>&nbsp;<span id="station">—</span></span>
      <span class="pill">Updated: <span id="updated">—</span></span>
      <span class="pill">Points: <span id="count">—</span></span>
    </div>

    <div class="toolbar" style="margin-top:10px">
      <div class="seg" role="tablist" aria-label="Data Source">
        <button class="btn" role="tab" data-mode="observed"  aria-pressed="true"  title="Recent observations (weather.gov)">Observed</button>
        <button class="btn" role="tab" data-mode="historical" aria-pressed="false" title="Historical ASOS via IEM">Historical</button>
        <button class="btn" role="tab" data-mode="forecast"  aria-pressed="false" title="Forecast grid pressure">Forecast</button>
      </div>
      <div class="right">
        <button id="toggleTime" class="btn chip" type="button" aria-pressed="true" title="Toggle UTC vs Local">Dates: Local</button>
        <button class="btn chip" data-quick="24" type="button">Last 24h</button>
        <button class="btn chip" data-quick="48" type="button">Last 48h</button>
        <button class="btn chip" data-quick="72" type="button">Last 72h</button>
      </div>
    </div>
  </header>

  <!-- Controls -->
  <section class="card pad">
    <div class="inputs">
      <div>
        <label for="start">Start (local)</label>
        <input id="start" type="datetime-local" />
      </div>
      <div>
        <label for="end">End (local)</label>
        <input id="end" type="datetime-local" />
      </div>

      <div class="row-flex">
        <!-- Location picker -->
        <div style="min-width:200px">
          <label for="locMode">Location</label>
          <select id="locMode" class="sel" title="Choose data location">
            <option value="default" selected>Denver</option>
            <option value="geo">My Location</option>
            <option value="custom">Custom</option>
          </select>
        </div>

        <!-- Custom coordinates (hidden unless Custom is selected) -->
        <div id="customCoords" class="hidden" style="min-width:260px">
          <label for="lat">Lat / Lon</label>
          <div class="row-flex">
            <input id="lat" type="number" step="0.0001" placeholder="Lat e.g. 39.7392" style="width:120px" />
            <input id="lon" type="number" step="0.0001" placeholder="Lon e.g. -104.9903" style="width:130px" />
            <button id="useCoords" class="btn" type="button" title="Use these coordinates">Use</button>
          </div>
        </div>

        <button id="apply" class="btn primary" type="button" title="Apply custom range">Apply</button>
      </div>
    </div>
  </section>

  <!-- Chart -->
  <section class="card pad chart-card" aria-label="Barometric pressure over time">
    <div class="status"><span class="dot" aria-hidden="true"></span><span id="status">Loading…</span></div>
    <div id="chart" role="img" aria-label="Line chart of barometric pressure"></div>
    <!-- Modern load mask over the chart -->
    <div id="chartMask" class="chart-mask" aria-hidden="true">
      <div class="spin" aria-hidden="true"></div>
      <div class="mask-text">Loading…</div>
    </div>
  </section>

  <section class="card table-card" aria-label="Data table">
    <table id="table">
      <thead>
      <tr>
        <th>Time</th>
        <th>Pressure (inHg)</th>
        <th class="muted hide-sm">hPa</th>
        <th class="muted hide-sm">Raw</th>
        <th class="muted hide-sm">Source</th>
      </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>
</div>

<script>
  // ---------- Config / DOM ----------
  const DENVER = { lat: 39.7392, lon: -104.9903 };
  let CURRENT = { ...DENVER }; // changes with My Location or Custom

  const statusEl  = document.getElementById('status');
  const stationEl = document.getElementById('station');
  const updatedEl = document.getElementById('updated');
  const countEl   = document.getElementById('count');
  const tableBody = document.querySelector('#table tbody');
  const toggleBtn = document.getElementById('toggleTime');
  const applyBtn  = document.getElementById('apply');
  const startInp  = document.getElementById('start');
  const endInp    = document.getElementById('end');
  const quickBtns = Array.from(document.querySelectorAll('button[data-quick]'));
  const modeTabs  = Array.from(document.querySelectorAll('.seg [data-mode]'));
  const chartMask = document.getElementById('chartMask');

  // Location controls
  const locModeSel   = document.getElementById('locMode');
  const customWrap   = document.getElementById('customCoords');
  const latInp       = document.getElementById('lat');
  const lonInp       = document.getElementById('lon');
  const useCoordsBtn = document.getElementById('useCoords');

  let currentMode = 'observed'; // 'observed' | 'historical' | 'forecast'

  // ---------- Time / Units ----------
  const toHpa  = pa => (pa == null ? null : pa / 100);
  const toInHgFromPa = pa => (pa == null ? null : pa / 3386.389);
  const inHgFromHpa = hpa => (hpa == null ? null : hpa / 33.86389);

  let useLocalTime = true;
  const fmtLocal = new Intl.DateTimeFormat(undefined, {
    month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit'
  });
  const fmtUTC = new Intl.DateTimeFormat(undefined, {
    month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit', timeZone: 'UTC'
  });
  const fmtUpdated = new Intl.DateTimeFormat(undefined, {
    year: 'numeric', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit'
  });
  const fDate = ms => {
    const d = new Date(ms);
    return useLocalTime ? fmtLocal.format(d) : fmtUTC.format(d) + ' UTC';
  };
  const setStatus = msg => { statusEl.textContent = msg; };
  const setDot = clr => { document.querySelector('.dot').style.background = clr; };

  const isoNowMinus = hours => new Date(Date.now() - hours*3600*1000).toISOString();

  // datetime-local helpers
  const pad2 = n => String(n).padStart(2, '0');
  function toLocalInputValue(d){
    const y=d.getFullYear(), m=pad2(d.getMonth()+1), day=pad2(d.getDate()),
            h=pad2(d.getHours()), min=pad2(d.getMinutes());
    return `${y}-${m}-${day}T${h}:${min}`;
  }
  function fromLocalInputValue(v){
    if(!v) return null;
    const [date, time] = v.split('T');
    const [Y,M,D] = date.split('-').map(Number);
    const [h,mi] = time.split(':').map(Number);
    return new Date(Y, M-1, D, h, mi, 0, 0);
  }

  // ---------- Data sources ----------
  async function getNearestStation(lat, lon){
    // weather.gov -> observationStations (for recent) and a likely ICAO ID for IEM
    const r1 = await fetch(`https://api.weather.gov/points/${lat},${lon}`);
    if(!r1.ok) throw new Error(`Points lookup failed: ${r1.status}`);
    const j1 = await r1.json();
    const listUrl = j1?.properties?.observationStations;
    if(!listUrl) throw new Error("No observationStations link for the point.");
    const r2 = await fetch(listUrl);
    if(!r2.ok) throw new Error(`Stations list failed: ${r2.status}`);
    const j2 = await r2.json();
    const id = j2?.features?.[0]?.properties?.stationIdentifier;
    if(!id) throw new Error("No nearby stations found.");
    return { stationId: id, pointsMeta: j1?.properties || {} };
  }

  // Recent observations (days): weather.gov
  async function getObserved(stationId, startIso, endIso){
    const url = `https://api.weather.gov/stations/${encodeURIComponent(stationId)}/observations?start=${encodeURIComponent(startIso)}&end=${encodeURIComponent(endIso)}`;
    const r = await fetch(url);
    if(!r.ok){
      if(r.status === 429) throw new Error("429 rate-limited by NWS. Try a smaller range.");
      throw new Error(`Observations failed: ${r.status}`);
    }
    const j = await r.json();
    const feats = j?.features || [];
    const rows = feats.map(f => {
      const p = f?.properties || {};
      const t = p?.timestamp ? new Date(p.timestamp) : null;
      const pa = p?.barometricPressure?.value ?? null;
      if(!t) return null;
      return {
        source: 'NWS',
        timeIso: t.toISOString(),
        timeMs: t.getTime(),
        Pa: pa,
        hPa: pa != null ? toHpa(pa) : null,
        inHg: pa != null ? toInHgFromPa(pa) : null,
        raw: pa
      };
    }).filter(Boolean);
    rows.sort((a,b) => a.timeMs - b.timeMs);
    return rows;
  }

  // Historical observations (months/years): IEM ASOS CSV (no key, no headers)
  async function getHistoricalIEM(icao, startDate, endDate){
    const s = new Date(startDate), e = new Date(endDate);
    const sy = s.getUTCFullYear(), sm = s.getUTCMonth()+1, sd = s.getUTCDate();
    const ey = e.getUTCFullYear(), em = e.getUTCMonth()+1, ed = e.getUTCDate();

    const url = `https://mesonet.agron.iastate.edu/cgi-bin/request/asos.py?station=${encodeURIComponent(icao)}&data=alti&data=mslp&tz=UTC&format=onlycomma&latlon=no&year1=${sy}&month1=${sm}&day1=${sd}&year2=${ey}&month2=${em}&day2=${ed}&time=0:00-23:59`;

    const r = await fetch(url);
    if(!r.ok) throw new Error(`IEM ASOS request failed: ${r.status}`);
    const txt = await r.text();
    const lines = txt.trim().split(/\r?\n/);
    const out = [];
    let header = null;
    for(const line of lines){
      if(!line) continue;
      const cols = line.split(',');
      if(!header){ header = cols.map(c => c.trim().toLowerCase()); continue; }
      const rec = {};
      header.forEach((h,i)=> rec[h] = cols[i] === '' ? null : cols[i]);
      const t = rec.valid ? new Date(rec.valid + 'Z') : null; // UTC
      if(!t || isNaN(t)) continue;

      const alti = rec.alti != null ? parseFloat(rec.alti) : null;
      const mslp = rec.mslp != null ? parseFloat(rec.mslp) : null;
      const inHg = Number.isFinite(alti) ? alti : (Number.isFinite(mslp) ? inHgFromHpa(mslp) : null);

      const row = {
        source: 'IEM',
        timeIso: t.toISOString(),
        timeMs: t.getTime(),
        Pa: Number.isFinite(mslp) ? mslp*100 : null,
        hPa: Number.isFinite(mslp) ? mslp : null,
        inHg: Number.isFinite(inHg) ? inHg : null,
        raw: Number.isFinite(alti) ? alti : (Number.isFinite(mslp) ? mslp : null)
      };
      out.push(row);
    }
    const clipStart = new Date(startDate).getTime();
    const clipEnd   = new Date(endDate).getTime();
    const clipped = out.filter(r => r.timeMs >= clipStart && r.timeMs <= clipEnd);
    clipped.sort((a,b)=>a.timeMs-b.timeMs);
    return clipped;
  }

  // Forecast (Open-Meteo: hourly mean sea level pressure -> inHg)
  async function getForecastPressure(lat, lon){
    const sDate = fromLocalInputValue(startInp.value) || new Date();
    const eDate = fromLocalInputValue(endInp.value)   || new Date(Date.now() + 48*3600*1000);

    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}` +
            `&hourly=pressure_msl&timezone=auto` +
            `&start_date=${sDate.toISOString().slice(0,10)}&end_date=${eDate.toISOString().slice(0,10)}`;

    const r = await fetch(url);
    if(!r.ok) throw new Error(`Forecast fetch failed: ${r.status}`);
    const j = await r.json();

    const times = j?.hourly?.time || [];
    const pres  = j?.hourly?.pressure_msl || [];
    if(!times.length || !pres.length) throw new Error("Forecast pressure not available from provider.");

    const rows = [];
    for(let i=0;i<times.length;i++){
      const t = new Date(times[i]);
      if(!isFinite(t)) continue;
      const hPa = pres[i];
      const inHg = inHgFromHpa(hPa);
      rows.push({
        source: 'Open-Meteo:pressure_msl',
        timeIso: t.toISOString(),
        timeMs: t.getTime(),
        Pa: Number.isFinite(hPa) ? hPa*100 : null,
        hPa: Number.isFinite(hPa) ? hPa : null,
        inHg: Number.isFinite(inHg) ? inHg : null,
        raw: hPa
      });
    }

    const s = sDate.getTime(), e = eDate.getTime();
    const clipped = rows.filter(r => r.timeMs >= s && r.timeMs <= e);
    clipped.sort((a,b)=>a.timeMs-b.timeMs);
    return clipped;
  }

  // ---------- Table / Chart ----------
  let lastRows = [];

  function renderTable(rows){
    tableBody.innerHTML = "";
    const frag = document.createDocumentFragment();
    for(const r of rows){
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${fDate(r.timeMs)}</td>
        <td>${Number.isFinite(r.inHg) ? r.inHg.toFixed(3) : "—"}</td>
        <td class="muted hide-sm">${Number.isFinite(r.hPa) ? r.hPa.toFixed(1) : "—"}</td>
        <td class="muted hide-sm">${r.raw ?? "—"}</td>
        <td class="muted hide-sm">${r.source}</td>
      `;
      frag.appendChild(tr);
    }
    tableBody.appendChild(frag);
  }

  let chart;
  function initChart(){
    chart = echarts.init(document.getElementById('chart'), null, { renderer: 'canvas' });
    const isSmall = matchMedia('(max-width: 540px)').matches;
    chart.setOption({
      animation: false,
      color: ['var(--accent)', 'var(--accent-2)', 'var(--accent-3)'],
      grid: { left: 52, right: 22, top: 12, bottom: isSmall ? 58 : 64 },
      tooltip: {
        trigger: 'axis',
        confine: true,
        axisPointer: { type: 'cross' },
        formatter: params => {
          if(!params?.length) return '';
          const time = fDate(params[0].value[0]);
          const lines = params.map(p => {
            const v = p.value[1];
            const hpa = v ? (v * 3386.389 / 100).toFixed(1) : '—';
            return `<div><span style="opacity:.8">${p.marker}${p.seriesName}:</span> <strong>${v?.toFixed(3) ?? '—'} inHg</strong> <span style="opacity:.75">(${hpa} hPa)</span></div>`;
          }).join('');
          return `<div style="font-size:12.5px">
                    <div style="opacity:.8;margin-bottom:4px">${time}</div>
                    ${lines}
                  </div>`;
        }
      },
      xAxis: {
        type: 'time',
        axisLabel: { hideOverlap: true, margin: 14, formatter: value => fDate(value) },
        axisLine: { lineStyle: { opacity: .4 } },
        splitLine: { show: true, lineStyle: { opacity: .08 } }
      },
      yAxis: {
        type: 'value',
        name: 'inHg',
        nameGap: 12,
        axisLine: { lineStyle: { opacity: .4 } },
        splitLine: { lineStyle: { opacity: .12 } },
        scale: true,
        min: 28.5,
        max: 31.0,
        axisLabel: { formatter: (v) => v.toFixed(1) }
      },
      dataZoom: [
        { type: 'inside', throttle: 40 }
        /* slider removed to hide bottom interactive bar */
      ],
      series: [
        {
          type: 'line',
          name: 'Observed',
          showSymbol: false,
          connectNulls: true,
          smooth: 0.18,
          lineStyle: { width: 2.6 },
          areaStyle: { opacity: .14 },
          data: []
        }
      ]
    });
    window.addEventListener('resize', () => chart.resize());
  }

  function setSeries(name, rows){
    const pts = rows.filter(r => Number.isFinite(r.inHg)).map(r => [r.timeMs, +r.inHg]);
    chart.setOption({
      series: [{ name, data: pts, areaStyle: { opacity: .14 }, lineStyle: { width: 2.6 } }],
      color: [name === 'Observed' ? getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()
              : name === 'Historical' ? getComputedStyle(document.documentElement).getPropertyValue('--accent-2').trim()
                      : getComputedStyle(document.documentElement).getPropertyValue('--accent-3').trim()]
    });
    if(pts.length){
      const ys = pts.map(p=>p[1]);
      const minVal = Math.min(...ys), maxVal = Math.max(...ys);
      const pad = Math.max((maxVal - minVal) * 0.12, 0.05);
      chart.setOption({ yAxis: { min: minVal - pad, max: maxVal + pad } });
    }
  }

  function refreshXAxisLabels(){
    const opt = chart.getOption();
    chart.setOption({ xAxis: [{ ...opt.xAxis[0] }] });
  }

  // ---------- Orchestration ----------
  let stationId = null;
  let pointsMeta = null;

  async function loadObservedRange(startIso, endIso){
    setStatus("Fetching recent observations (weather.gov) …");
    const rows = await getObserved(stationId, startIso, endIso);
    return rows;
  }

  async function loadHistoricalRange(startIso, endIso){
    setStatus("Fetching historical (IEM ASOS) …");
    const rows = await getHistoricalIEM(stationId, startIso, endIso);
    return rows;
  }

  async function loadForecastRange(startIso, endIso){
    setStatus("Fetching forecast (Open-Meteo) …");
    const all = await getForecastPressure(CURRENT.lat, CURRENT.lon);
    const s = new Date(startIso).getTime(), e = new Date(endIso).getTime();
    return all.filter(r => r.timeMs >= s && r.timeMs <= e);
  }

  // --- Helpers: load mask + future-range guard ---
  function showMask(){ chartMask.classList.add('show'); }
  function hideMask(){ chartMask.classList.remove('show'); }

  function snapToLast72h(){
    const end = new Date();
    const start = new Date(Date.now() - 72*3600*1000);
    startInp.value = toLocalInputValue(start);
    endInp.value   = toLocalInputValue(end);
  }

  function guardFutureForPastModes(){
    if(currentMode === 'forecast') return;
    const now = Date.now();
    const sDate = fromLocalInputValue(startInp.value);
    const eDate = fromLocalInputValue(endInp.value);
    if(!sDate || !eDate) return;
    if(eDate.getTime() > now || sDate.getTime() > now){
      snapToLast72h();
      setStatus("Selected dates were in the future — reset to last 72h.");
    }
  }

  async function applyRange(){
    showMask();
    try{
      guardFutureForPastModes();

      const sDate = fromLocalInputValue(startInp.value);
      const eDate = fromLocalInputValue(endInp.value);
      if(!(sDate && eDate) || isNaN(sDate) || isNaN(eDate) || sDate >= eDate){
        throw new Error("Please select a valid start and end.");
      }
      const sIso = sDate.toISOString();
      const eIso = eDate.toISOString();

      let rows = [];
      if(currentMode === 'observed'){
        rows = await loadObservedRange(sIso, eIso);
      }else if(currentMode === 'historical'){
        rows = await loadHistoricalRange(sIso, eIso);
      }else{
        rows = await loadForecastRange(sIso, eIso);
      }

      lastRows = rows;
      countEl.textContent = rows.length;
      updatedEl.textContent = fmtUpdated.format(new Date());
      renderTable(rows);
      setSeries(
              currentMode === 'observed' ? 'Observed' :
                      currentMode === 'historical' ? 'Historical' : 'Forecast',
              rows
      );
      setStatus(`Loaded ${rows.length} points.`);
      setDot('var(--ok)');
    }catch(err){
      console.error(err);
      setStatus(String(err));
      setDot('var(--err)');
      lastRows = [];
      renderTable([]);
      setSeries('Observed', []);
    }finally{
      hideMask();
    }
  }

  // ---------- Location helpers ----------
  async function updateStationAndRefresh(){
    showMask();
    try{
      setStatus("Finding nearest station…");
      const meta = await getNearestStation(CURRENT.lat, CURRENT.lon);
      stationId  = meta.stationId;
      pointsMeta = meta.pointsMeta;
      stationEl.textContent = stationId;
      await applyRange();
    }catch(e){
      console.error(e);
      setStatus(String(e.message || e));
      setDot('var(--err)');
    }finally{
      hideMask();
    }
  }

  locModeSel.addEventListener('change', async () => {
    const mode = locModeSel.value;
    customWrap.classList.toggle('hidden', mode !== 'custom');

    if(mode === 'default'){
      CURRENT = { ...DENVER };
      await updateStationAndRefresh();
    }else if(mode === 'geo'){
      try{
        setStatus("Requesting your location…");
        await new Promise((resolve, reject) => {
          if(!navigator.geolocation) return reject(new Error("Geolocation not supported."));
          navigator.geolocation.getCurrentPosition(
                  pos => { CURRENT = { lat: pos.coords.latitude, lon: pos.coords.longitude }; resolve(); },
                  err => reject(new Error("Location denied or unavailable.")),
                  { enableHighAccuracy: true, timeout: 10000, maximumAge: 300000 }
          );
        });
        await updateStationAndRefresh();
      }catch(e){
        console.error(e);
        setStatus(String(e.message || e));
        setDot('var(--err)');
      }
    }
  });

  useCoordsBtn.addEventListener('click', async () => {
    const lat = parseFloat(latInp.value);
    const lon = parseFloat(lonInp.value);
    if(!Number.isFinite(lat) || !Number.isFinite(lon)){
      setStatus("Enter valid latitude and longitude.");
      setDot('var(--warn)');
      return;
    }
    CURRENT = { lat, lon };
    await updateStationAndRefresh();
  });

  // ---------- UI events ----------
  toggleBtn.addEventListener('click', () => {
    useLocalTime = !useLocalTime;
    toggleBtn.setAttribute('aria-pressed', String(useLocalTime));
    toggleBtn.textContent = 'Dates: ' + (useLocalTime ? 'Local' : 'UTC');
    renderTable(lastRows);
    refreshXAxisLabels();
  });

  applyBtn.addEventListener('click', applyRange);

  quickBtns.forEach(b => b.addEventListener('click', async (e) => {
    const hrs = Number(e.currentTarget.dataset.quick);
    const end = new Date();
    const start = new Date(Date.now() - hrs*3600*1000);
    startInp.value = toLocalInputValue(start);
    endInp.value = toLocalInputValue(end);
    currentMode = 'observed';
    setPressed('observed');
    applyRange();
  }));

  modeTabs.forEach(btn => btn.addEventListener('click', () => {
    currentMode = btn.dataset.mode;
    setPressed(currentMode);
    if(currentMode === 'forecast'){
      const start = new Date();
      const end = new Date(Date.now() + 48*3600*1000);
      startInp.value = toLocalInputValue(start);
      endInp.value = toLocalInputValue(end);
    }
    applyRange();
  }));

  function setPressed(mode){
    modeTabs.forEach(b => b.setAttribute('aria-pressed', String(b.dataset.mode === mode)));
  }

  // ---------- Bootstrap ----------
  function defaultRange(){
    const end = new Date();
    const start = new Date(Date.now() - 72*3600*1000);
    startInp.value = toLocalInputValue(start);
    endInp.value   = toLocalInputValue(end);
  }

  async function main(){
    try{
      setStatus("Finding nearest station to Denver…");
      const meta = await getNearestStation(CURRENT.lat, CURRENT.lon);
      stationId  = meta.stationId;       // e.g., KDEN
      pointsMeta = meta.pointsMeta;
      stationEl.textContent = stationId;

      defaultRange();
      initChart();

      // Initial draw (Observed, last 72h)
      await applyRange();
    }catch(err){
      console.error(err);
      setStatus(String(err));
      setDot('var(--err)');
    }
  }

  main();
</script>
</body>
</html>
